#side Ehren
#color 000

#code
#const HelpChannel 1
#const ClaimFrequency 100
#const ClaimStaleTime 150
#var Home
#var LastClaim
#vector Dest

claim-stale-time:
  time ClaimStaleTime < if
    1
  else
    time ClaimStaleTime -
  then
return

doevents:
  Dest seek-location
  update-claim^
  peel-eyes^ Fight& ifg
  listen^ SeekDanger& ifg
  repair^
  autoconstruct
return

repair:
  manage-energy^ ifr
  armor max-armor < if
    max-repair-rate repair-rate!
  else
    0 repair-rate!
  then
return

listen:
  manage-energy^ if
    0 return
  then
  #const help-range 20
  #const help-time 10

  #var listen-time
  #var listen-retval
  #vector listen-position
  0 listen-retval!
  HelpChannel receive if

    listen-time!
    listen-position!

    listen-time time help-time - > if
      listen-position position dist 
      help-range < if
        listen-position Dest!
        1 listen-retval!
      then
    then
  then

  listen-retval
return

manage-energy:
  energy max-energy 3 / <
return


shoot:
  #var shoot-target-distance
  #var shoot-blast-direction
  #vector shoot-blast-velocity
  robot-distance shoot-target-distance!
;aim the shot
  robot-velocity velocity v- 2dup shoot-target-distance blaster-speed / vs* robot-position v+
  position dist blaster-speed / vs* robot-position v+
  position v- angle shoot-blast-direction!
  velocity blaster-speed shoot-blast-direction polar-to-rect v+ shoot-blast-velocity!
;look for friends
  0 robot-sensor-sees-enemies!
  1 robot-sensor-sees-friends!
  shoot-target-distance 2 / robot-sensor-focus-distance!
  shoot-blast-direction robot-sensor-focus-direction!
  fire-robot-sensor sync
  1 robot-sensor-sees-enemies!
  0 robot-sensor-sees-friends!
  0 robot-sensor-focus-distance!
;anybody in the way?
  robot-found if
    do
      robot-position position v- 2dup  ;vector to this robot
        shoot-blast-velocity robot-velocity v- unitize dot  ;how far along the shot-path
        dup radius > swap shoot-target-distance < and  ;is it between us and the target?
        rrot shoot-blast-velocity robot-velocity v- unitize cross  ;distance from shot-path
        abs robot-radius .2 + < and ifr  ;...and is it close to the path?
    next-robot while-loop
  then
;shoot
  shoot-blast-direction fire-blaster
  0 robot-sensor-sees-friends!
  1 robot-sensor-sees-enemies!
  1 robot-sensor-focus-distance!
return


peel-eyes:
  manage-energy^ if
    0 return
  then
  40 periodic-robot-sensor
  robot-found
  and
return

update-claim:
  LastClaim 
  time ClaimFrequency - 
  < if
    time LastClaim!
    time Home write
  then
return

arrived:
  position Dest dist radius <
return

; address -- bool
check-address:
    #var check-address-time
    read check-address-time!

    check-address-time
    claim-stale-time^
    <
return

address-in-bounds?:
  address-to-location^ 
  2dup 0 restrict-position
  v=
return

; compute an archimedes spiral starting from current position
; check each cell along the spiral for availability
; claim first available
find-home:
  #var find-home-r 1
  #var find-home-theta 0
  #var find-home-x 1
  #var find-home-address
  #const find-home-step 1
  position location-to-address^ Home!

  do 
    Home 0 = if 
      1 Home!
    then
    Home check-address^
  until
    find-home-step find-home-theta *
    find-home-x +
    find-home-r!

    find-home-r 100 mod find-home-r!

    find-home-r find-home-theta polar-to-rect
    position v+
    location-to-address^ find-home-address!

    find-home-address address-in-bounds?^ if
      find-home-address Home!
    then
    
    pi 8 /
    find-home-theta +
    find-home-theta!
  loop


  time Home write
  time LastClaim!
return

WaitForFood:
Home address-to-location^ Dest!
do
  doevents^
  40 periodic-food-sensor if
    food-found if
      food-position location-to-address^ Home = if
        SeekFood& jump
      else
        food-position location-to-address^ check-address^ if
          SeekFood& jump
        then
      then
    then
  then
forever

SeekFood:
food-position Dest!
do
  doevents^
  arrived^ Eat& ifg
forever

Eat:
do
  doevents^
  eaten WaitForFood& nifg
forever

GoHome:
Home address-to-location^ Dest!
do
  doevents^
  arrived^ WaitForFood& ifg
forever

Fight:
#var Fight-last-call
do
  Dest seek-location
  16 periodic-robot-sensor if
    robot-found if
      shoot^
      robot-position Dest!
      time Fight-last-call - 20 > if
        time Fight-last-call!
        robot-position time 3 HelpChannel send
      then
    else
      WaitForFood& jump
    then
  then
forever

SeekDanger:
time print
do
  Dest seek-location
  position Dest blaster-range in-range if
    Fight& jump
  then
  20 periodic-robot-sensor if
    robot-found if
      Fight& jump
    then
  then
forever
return


; x y -> offset
location-to-address:
  #var location-to-address-retval
  10 / floor
  swap
  10 / floor 10 *
  +
  location-to-address-retval!
  location-to-address-retval 0 = if
    1
  else
    location-to-address-retval
  then
return

address-to-location:
  dup
  10 / floor
  10 * 5 +
  swap
  10 mod
  10 * 5 +
return

#type Eater
#hardware
  repair-rate .1
  processor 20
  food-sensor 10
  solar-cells .02
  engine .1
  eater 1.1
  energy 200 75
  constructor 1
  armor 60
  blaster 12 7 16
  robot-sensor 7 2
#code
#start
do time id 10 * < while
  sync
loop
find-home^
GoHome& jump


#end
