#side Ehren
#color 000

#code
#const HelpChannel 1
#const ClaimFrequency 100
#const ClaimStaleTime 150
#var Home
#var LastClaim
#var Fighting
#vector Dest
#seed 2 1 1 1 1

claim-stale-time:
  time ClaimStaleTime < if
    1
  else
    time ClaimStaleTime -
  then
return

doevents:
  Dest seek-location
  manage-energy^ ifr

  autoconstruct
  update-claim^
  peel-eyes^ Fight& ifg
  listen^ SeekDanger& ifg
  incoming^ SeekDanger& ifg
return

incoming:
  #var incoming-retval
  0 incoming-retval!

  20 periodic-shot-sensor if
    shot-found if
      shot-position
      shot-velocity vnegate
      50 vs*
      v+
      Dest!
      1 incoming-retval!
    then
  then
  incoming-retval
return

listen:
  #const help-range 30
  #const help-time 100

  #var listen-time
  #var listen-retval
  #vector listen-position
  0 listen-retval!
  HelpChannel receive if

    listen-time!
    listen-position!

    listen-time time help-time - > if
      listen-position position dist 
      help-range < if
        listen-position Dest!
        1 listen-retval!
      then
    then
  then

  listen-retval
return

manage-energy:
  energy max-energy 3 / <
return


peel-eyes:
  40 periodic-robot-sensor
  robot-found
  and
return

update-claim:
  Fighting ifr
  LastClaim 
  time ClaimFrequency - 
  < if
    time LastClaim!
    time Home write
  then
return

arrived:
  position Dest dist radius <
return

; address -- bool
check-address:
    #var check-address-time
    read check-address-time!

    check-address-time
    claim-stale-time^
    <
return

address-in-bounds?:
  address-to-location^ 
  2dup 0 restrict-position
  v=
return

; compute an archimedes spiral starting from current position
; check each cell along the spiral for availability
; claim first available
find-home:
  #var find-home-r 1
  #var find-home-theta 0
  #var find-home-x 1
  #var find-home-address
  #const find-home-step 1
  position location-to-address^ Home!

  do 
    Home 0 = if 
      1 Home!
    then
    Home check-address^
  until
    find-home-step find-home-theta *
    find-home-x +
    find-home-r!

    find-home-r 100 mod find-home-r!

    find-home-r find-home-theta polar-to-rect
    position v+
    location-to-address^ find-home-address!

    find-home-address address-in-bounds?^ if
      find-home-address address-to-location^ position dist 75 < if
        find-home-address Home!
      then
    then
    
    pi 8 /
    find-home-theta +
    find-home-theta!
  loop


  time Home write
  time LastClaim!
return

WaitForFood:
Home address-to-location^ Dest!
do
  doevents^
  40 periodic-food-sensor if
    food-found if
      food-position location-to-address^ Home = if
        SeekFood& jump
      else
        food-position location-to-address^ check-address^ if
          food-position Home address-to-location^ dist 14 < if
            SeekFood& jump
          then
        then
      then
    then
  then
forever

SeekFood:
food-position Dest!
do
  doevents^
  arrived^ Eat& ifg
forever

Eat:
do
  doevents^
  armor max-armor < if
    max-repair-rate repair-rate!
  else
    0 repair-rate!
  then
  eaten nif
    0 repair-rate!
    WaitForFood& jump
  then
forever

GoHome:
Home address-to-location^ Dest!
do
  doevents^
  arrived^ WaitForFood& ifg
forever

Fight:
#var Fight-last-call
#var fighting-distance
#vector target-position
#vector target-velocity
#var target-distance
1 Fighting!
0 constructor-type!
.8 grenades-range * fighting-distance!
do
  position target-position v- unitize fighting-distance vs* target-position v+
    target-velocity seek-moving-location
  time robot-sensor-time grenades-reload-time + >= if
    fire-robot-sensor sync
    robot-found if
      record-target^
      energy grenades-firing-cost > if
        robot-position robot-velocity lead-grenade
      then
      time Fight-last-call - 20 > if
        time Fight-last-call!
        robot-position time 3 HelpChannel send
      then
    else
      0 Fighting!
      find-home^
      WaitForFood& jump
    then
  then
forever

record-target:
  robot-position target-position!
  robot-velocity target-velocity!
  robot-distance target-distance!
return

SeekDanger:
0 constructor-type!
do
  Dest seek-location
  position Dest grenades-range in-range if
    Fight& jump
  then
  20 periodic-robot-sensor if
    robot-found if
      Fight& jump
    then
  then
forever
return


; x y -> offset
location-to-address:
  #var location-to-address-retval
  10 / floor
  swap
  10 / floor 10 *
  +
  location-to-address-retval!
  location-to-address-retval 0 = if
    1
  else
    location-to-address-retval
  then
return

address-to-location:
  dup
  10 / floor
  10 * 5 +
  swap
  10 mod
  10 * 5 +
return

#type Killbot
#decoration FF0 circle
#hardware
  solar-cells .04
  repair-rate .1
  processor 50
  food-sensor 10
  shot-sensor 9
  engine .16
  eater 1.1
  energy 200 75
  constructor 1
  armor 150
  grenades 30 14 16
  robot-sensor 14 2
#code
#start
do time id 10 * < while
  sync
loop
find-home^
GoHome& jump

type Seeder
#color F00
#hardware
  processor 10
  energy 800 200
  engine 2
  constructor 4
  food-sensor 20
  eater 10
  armor 500
#code
do
  Dest seek-location
  energy 200 > if
    constructor-max-rate constructor-rate!
  else
    0 constructor-rate!
  then

  1 constructor-type!
  eaten nif
    40 periodic-food-sensor if
      food-position Dest!
    then
  then
forever


#end
