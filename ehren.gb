#side Ehren
#color 000

#code
#const HelpChannel 1
#const ClaimFrequency 100
#const ClaimStaleTime 150
#var Home
#var LastClaim
#vector Dest

claim-stale-time:
  time ClaimStaleTime < if
    1
  else
    time ClaimStaleTime -
  then
return

doevents:
  Dest seek-location
  update-claim^
  peel-eyes^ Fight& ifg
  autoconstruct
return

peel-eyes:
  40 periodic-robot-sensor
  robot-found
  and
return

update-claim:
  LastClaim 
  time ClaimFrequency - 
  < if
    time LastClaim!
    time Home write
  then
return

arrived:
  position Dest dist radius <
return

; address -- bool
check-address:
    #var check-address-time
    read check-address-time!

    check-address-time
    claim-stale-time^
    <
return

address-in-bounds?:
  address-to-location^ 
  2dup 0 restrict-position
  v=
return

; compute an archimedes spiral starting from current position
; check each cell along the spiral for availability
; claim first available
find-home:
  #var find-home-r 1
  #var find-home-theta 0
  #var find-home-x 1
  #var find-home-address
  #const find-home-step 1
  position location-to-address^ Home!

  do 
    Home 0 = if 
      1 Home!
    then
    Home check-address^
  until
    find-home-step find-home-theta *
    find-home-x +
    find-home-r!

    find-home-r 100 mod find-home-r!

    find-home-r find-home-theta polar-to-rect
    position v+
    location-to-address^ find-home-address!

    find-home-address address-in-bounds?^ if
      find-home-address Home!
    then
    
    pi 8 /
    find-home-theta +
    find-home-theta!
  loop


  time Home write
  time LastClaim!
return

WaitForFood:
Home address-to-location^ Dest!
do
  doevents^
  40 periodic-food-sensor if
    food-found if
      food-position location-to-address^ Home = if
        SeekFood& jump
      then
    then
  then
forever

SeekFood:
food-position Dest!
do
  doevents^
  arrived^ Eat& ifg
forever

Eat:
do
  doevents^
  eaten WaitForFood& nifg
forever

GoHome:
Home address-to-location^ Dest!
do
  doevents^
  arrived^ WaitForFood& ifg
forever

Fight:
do
  Dest seek-location
  8 periodic-robot-sensor if
    robot-found if
      robot-position robot-velocity lead-blaster
    else
      GoHome& jump
    then
  then
forever


; x y -> offset
location-to-address:
  10 / floor
  swap
  10 / floor 10 *
  +
return

address-to-location:
  dup
  10 / floor
  10 * 5 +
  swap
  10 mod
  10 * 5 +
return

#type Eater
#hardware
  processor 20
  food-sensor 7
  solar-cells .02
  engine .1
  eater 1
  energy 60 60
  constructor 1
  armor 60
  blaster 12 7 8
  robot-sensor 7
#code
#start
do time id 10 * < while
  sync
loop
find-home^
GoHome& jump


#end
