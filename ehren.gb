#side Ehren
#color F1F
#type Eater
#hardware
  constructor 1
  eater 1
  food-sensor 8
  processor 20
  engine .5
  energy 100 100
#code

#vector dest
#vector origin
#vector food-at
#var delay 100

new-dest:
  0 world-width random 0 world-height random dest!
return


; -> bool
; whether a food is my claim
check-mine:
  food-position dest v- drop abs 5.1 <
  food-position dest v- swap drop abs 5.1 <
  and
return

search-food:
  do
    40 periodic-food-sensor if
      food-found if
        check-mine& call if
          food-position food-at!
          seek-food& jump
        then
      then
    then

    dest seek-location
  forever
return


eating:
do
  autoconstruct
  eaten nif
    0 constructor-rate!
    search-food& jump
  then

  food-at seek-location
forever
return


seek-food:
  do
    eaten nif
      food-at seek-location
      position food-at dist .5 < if
        search-food& jump
      then
    else
      eating& jump
    then
  forever
return

go-home:
  do
    dest seek-location
    position dest dist 1 < if
      search-food& jump
    then
  forever
return


find-home:
  #vector origin
  #var nsteps 0
  #var c 0
  #var i 0
  #vector step 10 0
  #var x 0

  1 vread origin!

  origin dest!

  do x id < while
    i nsteps < if
      i 1 + i!
    else
      step rotate& call step!
      0 i!
      c if
        nsteps 1 + nsteps!
        0 c!
      else
        1 c!
      then
    then
    dest step v+ dest!

    dest in-map& call if
      x 1 + x!
    then
  loop

return

; x(vector) -> bool
; true if the vector is contained within the bounds of the map
in-map:
  2dup .1 restrict-position v=
return

; vector -> vector
; rotates input 90ยบ
rotate:
  rect-to-polar pi/2 + polar-to-rect
return


#start

id 1 = if
  position 10 / floor 10 *
  swap 10 / floor 10 *
  swap
  1 vwrite
then

find-home& call

id 1 = if
  1 vread dest!
then

go-home& jump

#end
